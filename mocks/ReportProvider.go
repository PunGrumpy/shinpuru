// Code generated by mockery v2.16.0. DO NOT EDIT.

package mocks

import (
	discordgo "github.com/bwmarrin/discordgo"
	database "github.com/zekroTJA/shinpuru/internal/services/database"

	discordutil "github.com/zekroTJA/shinpuru/pkg/discordutil"

	mock "github.com/stretchr/testify/mock"

	models "github.com/zekroTJA/shinpuru/internal/models"

	multierror "github.com/zekroTJA/shinpuru/pkg/multierror"
)

// ReportProvider is an autogenerated mock type for the Provider type
type ReportProvider struct {
	mock.Mock
}

// ExpireExpiredReports provides a mock function with given fields:
func (_m *ReportProvider) ExpireExpiredReports() *multierror.MultiError {
	ret := _m.Called()

	var r0 *multierror.MultiError
	if rf, ok := ret.Get(0).(func() *multierror.MultiError); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*multierror.MultiError)
		}
	}

	return r0
}

// ExpireLastReport provides a mock function with given fields: guildID, victimID, typ
func (_m *ReportProvider) ExpireLastReport(guildID string, victimID string, typ int) error {
	ret := _m.Called(guildID, victimID, typ)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int) error); ok {
		r0 = rf(guildID, victimID, typ)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PushBan provides a mock function with given fields: rep
func (_m *ReportProvider) PushBan(rep models.Report) (models.Report, error) {
	ret := _m.Called(rep)

	var r0 models.Report
	if rf, ok := ret.Get(0).(func(models.Report) models.Report); ok {
		r0 = rf(rep)
	} else {
		r0 = ret.Get(0).(models.Report)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Report) error); ok {
		r1 = rf(rep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PushKick provides a mock function with given fields: rep
func (_m *ReportProvider) PushKick(rep models.Report) (models.Report, error) {
	ret := _m.Called(rep)

	var r0 models.Report
	if rf, ok := ret.Get(0).(func(models.Report) models.Report); ok {
		r0 = rf(rep)
	} else {
		r0 = ret.Get(0).(models.Report)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Report) error); ok {
		r1 = rf(rep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PushMute provides a mock function with given fields: rep
func (_m *ReportProvider) PushMute(rep models.Report) (models.Report, error) {
	ret := _m.Called(rep)

	var r0 models.Report
	if rf, ok := ret.Get(0).(func(models.Report) models.Report); ok {
		r0 = rf(rep)
	} else {
		r0 = ret.Get(0).(models.Report)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Report) error); ok {
		r1 = rf(rep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PushReport provides a mock function with given fields: rep
func (_m *ReportProvider) PushReport(rep models.Report) (models.Report, error) {
	ret := _m.Called(rep)

	var r0 models.Report
	if rf, ok := ret.Get(0).(func(models.Report) models.Report); ok {
		r0 = rf(rep)
	} else {
		r0 = ret.Get(0).(models.Report)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Report) error); ok {
		r1 = rf(rep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeMute provides a mock function with given fields: guildID, executorID, victimID, reason
func (_m *ReportProvider) RevokeMute(guildID string, executorID string, victimID string, reason string) (*discordgo.MessageEmbed, error) {
	ret := _m.Called(guildID, executorID, victimID, reason)

	var r0 *discordgo.MessageEmbed
	if rf, ok := ret.Get(0).(func(string, string, string, string) *discordgo.MessageEmbed); ok {
		r0 = rf(guildID, executorID, victimID, reason)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.MessageEmbed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(guildID, executorID, victimID, reason)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RevokeReport provides a mock function with given fields: rep, executorID, reason, wsPublicAddr, db, s
func (_m *ReportProvider) RevokeReport(rep models.Report, executorID string, reason string, wsPublicAddr string, db database.Database, s discordutil.ISession) (*discordgo.MessageEmbed, error) {
	ret := _m.Called(rep, executorID, reason, wsPublicAddr, db, s)

	var r0 *discordgo.MessageEmbed
	if rf, ok := ret.Get(0).(func(models.Report, string, string, string, database.Database, discordutil.ISession) *discordgo.MessageEmbed); ok {
		r0 = rf(rep, executorID, reason, wsPublicAddr, db, s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*discordgo.MessageEmbed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(models.Report, string, string, string, database.Database, discordutil.ISession) error); ok {
		r1 = rf(rep, executorID, reason, wsPublicAddr, db, s)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewReportProvider interface {
	mock.TestingT
	Cleanup(func())
}

// NewReportProvider creates a new instance of ReportProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewReportProvider(t mockConstructorTestingTNewReportProvider) *ReportProvider {
	mock := &ReportProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
